[아키텍쳐]
쿠버네티스는 크게 마스터(Master)와 노드(Node)라는 두 개의 컴포넌트로 분리된다.
- 마스터: k8s의 설정 환경을 저장하고 전체 클러스터를 관리하는 역할을 수행
- 노드: 파드, 컨테이너 등 k8s 위에서 동작하는 워크로드를 호스팅하는 역할을 수행

모듈화가 되어 있으며, 기능 확장을 위해서 플러그인 설치 가능. 
- 모니터링 정보를 저장하기 위해 Influx DB 혹은 Prometheus 등의 DB 설치 가능.
- 커스텀 인터페이스 개발을 통해 알맞은 저장소를 개발하여 연결 가능.

============================================================================
[마스터]
- 쿠버네티스 클러스터 전체를 제어하는 시스템
- API 서버, 스케쥴러, 컨트롤러 매니져, etcd로 구성됨.

1) API 서버(kube-apiserver) : k8s 내부에서 명령을 주고 받는 서버
- 쿠버네티스의 모든 기능들을 REST API로 제공하고 그에 대한 명령을 처리하는 역할.
- 쿠버네티스는 모든 명령과 통신을 API를 통해서 진행. 그 중심이 API 서버.
- etcd, kube-scheduler, kube-controller-manager와 통신

2) etcd
- 쿠버네티스 클러스터의 DB 역할이 되는 서버. 설정값이나 클러스터의 상태가 저장됨.  
- etcd라는 분산형 key/value 스토어 오픈소스로 k8s 클러스터의 상태나 설정 정보를 저장.

3) 스케쥴러(kube-scheduler)
- Pod, 서비스 등 각 리소스들을 적절한 노드에 할당하는 역할.

4) 컨트롤러 매니져(kube-controller-manager)
- 각종 컨트롤러를 생성하고, 이를 각 노드에 배포하며, 이를 관리하는 역할을 수행.
- 컨트롤러들: Replica controller, Service controller, Volume Controller, Node controller 등

5) DNS : 리소스의 위치 정보를 얻는 내부 DNS 서버 (Service discovery 패턴)
- 쿠버네티스는 리소스의 엔드포인트(Endpoint)를 내부 DNS 서버로 맵핑하고 관리함.
- Pod나 서비스 등은 동적으로 생성되는 리소스이므로 배정되는 IP 주소가 계속 변경됨.
=> 새로운 리소스가 생기면, 해당 리소스에 대한 IP 주소와 DNS 이름을 등록하여 
   DNS 이름을 기반으로 리소스에 접근할 수 있도록 함.

=================================================================================
[노드]
- 마스터에 의해 명령을 받고 실제 워크로드를 생성하여 서비스하는 컴포넌트.
- Kubelet, Kube-proxy,cAdvisor 그리고 컨테이너 런타임이 노드에 배포됨.

1) kubelet : 노드에 배포되는 에이전트
- 마스터의 API 서버와 통신하는 역할.
- 노드가 수행해야 할 명령을 받아서 수행 & 노드의 상태 등을 마스터로 전달하는 역할.

2) kube-proxy
- 노드로 들어오는 네트워크 트래픽을 적절한 컨테이너로 라우팅함.
- 로드밸런싱 등 노드로 들어오고 나가는 네트워크 트래픽을 프록시함.
- 노드와 마스터 간의 네트워크 통신을 관리함. 

3) container runtime
- Pod를 통해서 배포된 컨테이너를 실행
- 도커 컨테이너, 그 이외에도 rkt(보안이 강화된 컨테이너), Hyper container 등의 런타임 컨테이너 존재. 

4) cAdvisor: 각 노드에서 기동되는 모니터링 에이전트
- 노드 내에서 가동되는 컨테이너들의 상태와 성능 등의 정보를 수집하여 마스터 서버의 API 서버로 전달.
- 해당 데이터들은 주로 모니터링을 위해서 사용됨.

=================================================================================